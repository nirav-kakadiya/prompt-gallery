// Prisma Schema for Prompt Gallery
// Connected to Supabase PostgreSQL

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
  schemas   = ["public"]
}

// Profile model (extends Supabase auth.users)
model Profile {
  id                  String    @id @db.Uuid
  email               String?   @unique
  username            String?   @unique
  name                String?
  bio                 String?
  avatarUrl           String?   @map("avatar_url")
  role                String    @default("user")
  promptCount         Int       @default(0) @map("prompt_count")
  totalCopies         Int       @default(0) @map("total_copies")
  totalLikes          Int       @default(0) @map("total_likes")
  createdAt           DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt           DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  prompts             Prompt[]
  likes               Like[]
  collections         Collection[]
  savedCollections    SavedCollection[]
  apiKeys             ApiKey[]
  reports             Report[]

  @@map("profiles")
  @@schema("public")
}

// Main Prompt model
model Prompt {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title           String
  slug            String    @unique
  promptText      String    @map("prompt_text")
  type            String
  status          String    @default("published")
  imageUrl        String?   @map("image_url")
  thumbnailUrl    String?   @map("thumbnail_url")
  videoUrl        String?   @map("video_url")
  blurhash        String?
  category        String?
  style           String?
  sourceUrl         String?   @map("source_url")
  sourceType        String?   @map("source_type")
  authorProfileLink String?   @map("author_profile_link")
  isPublic        Boolean   @default(true) @map("is_public")
  promptTextHash  String?   @unique @map("prompt_text_hash") @db.VarChar(64)
  authorId        String?   @map("author_id") @db.Uuid
  metadata        Json      @default("{}")
  viewCount       Int       @default(0) @map("view_count")
  copyCount       Int       @default(0) @map("copy_count")
  likeCount       Int       @default(0) @map("like_count")
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  publishedAt     DateTime? @map("published_at") @db.Timestamptz

  // Relations
  author            Profile?           @relation(fields: [authorId], references: [id], onDelete: SetNull)
  likes             Like[]
  collectionPrompts CollectionPrompt[]
  promptTags        PromptTag[]
  reports           Report[]
  images            PromptImage[]

  @@index([type])
  @@index([status])
  @@index([authorId])
  @@index([createdAt])
  @@index([slug])
  @@index([category])
  @@index([style])
  @@index([copyCount(sort: Desc)])
  @@index([status, type])
  @@index([status, createdAt(sort: Desc)])
  @@index([isPublic])
  @@map("prompts")
  @@schema("public")
}

// PromptImage model for multiple images per prompt
model PromptImage {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  promptId      String   @map("prompt_id") @db.Uuid
  imageUrl      String   @map("image_url")
  thumbnailUrl  String?  @map("thumbnail_url")
  blurhash      String?
  displayOrder  Int      @default(0) @map("display_order")
  caption       String?
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz

  prompt        Prompt   @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@index([promptId, displayOrder])
  @@map("prompt_images")
  @@schema("public")
}

// Tag model
model Tag {
  id          String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String      @unique
  slug        String      @unique
  category    String?
  promptCount Int         @default(0) @map("prompt_count")
  createdAt   DateTime    @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  promptTags  PromptTag[]

  @@map("tags")
  @@schema("public")
}

// Junction table for Prompt <-> Tag
model PromptTag {
  promptId  String   @map("prompt_id") @db.Uuid
  tagId     String   @map("tag_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  prompt    Prompt   @relation(fields: [promptId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([promptId, tagId])
  @@map("prompt_tags")
  @@schema("public")
}

// Category model
model Category {
  id           String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name         String    @unique
  slug         String    @unique
  description  String?
  icon         String?
  parentId     String?   @map("parent_id") @db.Uuid
  promptCount  Int       @default(0) @map("prompt_count")
  displayOrder Int       @default(0) @map("display_order")
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz

  @@map("categories")
  @@schema("public")
}

// Like model for user interactions
model Like {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  promptId  String   @map("prompt_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  user      Profile  @relation(fields: [userId], references: [id], onDelete: Cascade)
  prompt    Prompt   @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@unique([userId, promptId])
  @@map("likes")
  @@schema("public")
}

// Collection model for organizing prompts
model Collection {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name            String
  description     String?
  coverImageUrl   String?  @map("cover_image_url")
  isPublic        Boolean  @default(true) @map("is_public")
  ownerId         String?  @map("owner_id") @db.Uuid
  promptCount     Int      @default(0) @map("prompt_count")
  saveCount       Int      @default(0) @map("save_count")
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  owner           Profile?           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  prompts         CollectionPrompt[]
  savedBy         SavedCollection[]

  @@index([isPublic])
  @@index([ownerId])
  @@map("collections")
  @@schema("public")
}

// Junction table for Collection <-> Prompt
model CollectionPrompt {
  collectionId  String   @map("collection_id") @db.Uuid
  promptId      String   @map("prompt_id") @db.Uuid
  displayOrder  Int      @default(0) @map("display_order")
  addedAt       DateTime @default(now()) @map("added_at") @db.Timestamptz

  collection    Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  prompt        Prompt     @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@id([collectionId, promptId])
  @@map("collection_prompts")
  @@schema("public")
}

// Saved Collections - tracks which users have saved which public collections
model SavedCollection {
  userId        String   @map("user_id") @db.Uuid
  collectionId  String   @map("collection_id") @db.Uuid
  savedAt       DateTime @default(now()) @map("saved_at") @db.Timestamptz

  user          Profile    @relation(fields: [userId], references: [id], onDelete: Cascade)
  collection    Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@id([userId, collectionId])
  @@map("saved_collections")
  @@schema("public")
}

// View buffer for batched updates
model ViewBuffer {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  promptId  String   @map("prompt_id") @db.Uuid
  count     Int      @default(1)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([createdAt])
  @@index([promptId])
  @@map("view_buffer")
  @@schema("public")
}

// Copy buffer for batched updates
model CopyBuffer {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  promptId  String   @map("prompt_id") @db.Uuid
  count     Int      @default(1)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([createdAt])
  @@index([promptId])
  @@map("copy_buffer")
  @@schema("public")
}

// API Key for extension authentication
model ApiKey {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  name        String
  keyHash     String    @map("key_hash")
  keyPrefix   String    @map("key_prefix")
  scopes      Json      @default("[]")
  lastUsedAt  DateTime? @map("last_used_at") @db.Timestamptz
  expiresAt   DateTime? @map("expires_at") @db.Timestamptz
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz

  user        Profile   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([keyPrefix])
  @@map("api_keys")
  @@schema("public")
}

// Contact message model
model ContactMessage {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String
  email     String
  subject   String
  message   String
  status    String   @default("new")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  @@index([status])
  @@index([createdAt])
  @@map("contact_messages")
  @@schema("public")
}

// Report model for reporting prompts
model Report {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  promptId  String   @map("prompt_id") @db.Uuid
  userId    String?  @map("user_id") @db.Uuid
  reason    String
  details   String?
  status    String   @default("pending")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  prompt    Prompt   @relation(fields: [promptId], references: [id], onDelete: Cascade)
  user      Profile? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([promptId])
  @@index([status])
  @@map("reports")
  @@schema("public")
}
